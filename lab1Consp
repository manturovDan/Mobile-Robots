дана непрямоугольная матрица, найти макс по строкам, среди них мин. числа с дв точностью
структурное программирование

несколько файлов: 2 исходных файла cpp (1 с необходимыми функциями и 2й - функция main) реализации и заголовочный файл с определениями

совокурность функций
-main: 
	ввод матрицы с проверками
		кол во строк, кол во эл, сами эл [int + double]
	вывод ввода (отладка)
	формирование решения задачи [поиск максимума, поиск минимума]
	освобождение памяти ()

функция ввода:
	через return - код завершения
	int getNum(int &a) { //double - перегрузка функций ###
		std::cin>>a;
		if (!std::cin.good()) //good() возвр. истина если корректно, иначе - ложь
			return -1; //Нужно аварийной завершить программу
		return 1
	}

### шаблон функции. С помощбю шаблона можно в качестве параметра использовать тип данных. 
	//сначала компилятор ищет шаблон
	template <class T> //в шаблоне будет использован параметр Т, он может быть использован везде где указывается тип данных
	int getNum(T &a) { //double - перегрузка функций
		std::cin>>a;
		if (!std::cin.good()) //good() возвр. истина если корректно, иначе - ложь
			return -1; //Нужно аварийной завершить программу
		return 1
	
поиск максимума.минимума
	double max(int n, double[]a) { //[]a - указатель на 1 элемент последовательности (конструкция только для вызова функции)
		double res = a[0];
		for(int i = 1; i < n; ++i) {
			if (a[i] > res) { //для минимума < - можно сделать 1 функцию (с флагом)
				res = a[i]
			}
		}
		return res;
	}
	//можно использовать указатель на функцию, возвращающую bool - исьтину или ложь
	double minmax(int n, double[]a, bool (*f)()) { //f - указатель на функцию, имеющую 2 параметра (для стравнения) и возвращать bool
		...
			if(f(a[i], res)) {
				...
			}
		...
	}

	//такие мелкие функции лучше делать inline
	bool isGreater(double a, double b)
		return a > b;
	bool isLess(double a, double b)
		return a < b;

	...вызов
	minmax(n, ar, isGreater);

///////////////

//файл main.cpp
#include <iostream>
#include "prog1.h" //заголовочный файл

using namespace prog1;//использование пространисва имён



int main() {
	int m; //кол во строк
	Line *arr = nullptr; // не просто define переменная, а специальный объект, в некоорых ситуациях отличный от NULL
	double res;

	arr = input(m);
	if (!arr) {
		std::cout<<"ошибка и тд"<<std::endl; // std::endl - манимулятор тч содержжимое буфера выталкивается на экран, курсор переводится на начало следующей строки
		return 1;
	}

	output("Source: ", m, arr);
	if(minmax(arr, m, res)) {
		std::cout<<"ошибка...."<<std::endl;
		erase(arr, m);
		return 1;
	}

	std::cout<<"res = "<<res<<std::endl;
	erase(arr, m);
	return 0;
}

//файл prog1.h прототипы тут. также реализация шаблонов и inline функций
namespace prog1 {
	struct Line {
		int n;
		double *a; //string of matrix
	};

	template <class T>
	int getNum(T &a) {
		...
	}

	inline bool isGreater(double a, double b) 
		...
	inline bool isLess(double a, double b)
		...

	//prototypes
	Line *input(int &);
	void output(counst char*, Line a[], int m);
	Line *easre(Line *&a, int m) //ссылка на указатель тк надо изменить значение 1 параметра
	int minmax(Line a[], int m, double &);
	double minmax(double a[], int n, boolf (*f)(double, double));
}